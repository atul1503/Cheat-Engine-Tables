{$lua}

[ENABLE]

--------------------------------------------------------------------------------
-- Gear-Locked Movement with Timer (50 ms)
-- - Holds constant speed (selected from speedTable) while you hold UP (↑)
-- - W/S changes gear
-- - DOWN (↓) stops immediately
-- - Timer-based enforcement every 50 ms for smooth, continuous control
-- - Full cleanup on enable AND disable (prevents zombie timers or duplicate hotkeys)
--------------------------------------------------------------------------------

-- =========================
-- Config
-- =========================
local inGearMul=1.02
local outGearMul=1.1
speedTable = speedTable or {2,4,8,16,16*1.5,16*1.5^2,16*1.5^3,16*1.5^4}
index = index or 1  -- current gear index (persist across re-enables if you want)

-- Memory record descriptions for velocity components
speedXString = 'xspeed'
speedYString = 'yspeed'

-- Timer behavior
local TICK_MS = 50
alwaysEnforce = true  -- true = always keep speed at current gear (no need to hold UP)

-- Virtual-key codes
local VK_UP   = 0x26
local VK_DOWN = 0x28
local VK_W    = 0x57
local VK_S    = 0x53

-- =========================
-- Safety: pre-clean any leftovers from prior enable cycles
-- (Prevents zombie timers and duplicate hotkeys if user toggles script repeatedly)
-- =========================
local function safeDestroy(obj)
  if obj then
    pcall(function() obj.destroy() end)
  end
end

-- Kill any old items before creating new ones
safeDestroy(gearTimer)  gearTimer = nil
safeDestroy(hk1)        hk1 = nil
safeDestroy(hk2)        hk2 = nil
safeDestroy(incGear)    incGear = nil
safeDestroy(decGear)    decGear = nil

-- =========================
-- Utilities
-- =========================
local function getLen(tbl)
  local count=0
  for _ in pairs(tbl) do count=count+1 end
  return count
end

local function setEventually(xr,yr,vx,vy,r,target,delta)
      if r>target then
          if r/delta>=target then
             xr.Value=vx/delta
             yr.Value=vy/delta
          else
             local ratio=target/r
             xr.Value=xr.Value*ratio
             yr.Value=yr.Value*ratio
          end
      else
          if r*delta<=target then
             xr.Value=vx*delta
             yr.Value=vy*delta
          else
             local ratio=target/r
             xr.Value=xr.Value*ratio
             yr.Value=yr.Value*ratio
          end
      end
end


local function getRecords()
  local t=getAddressList()
  local xr = t and t.getMemoryRecordByDescription(speedXString) or nil
  local yr = t and t.getMemoryRecordByDescription(speedYString) or nil
  return xr, yr
end

-- =========================
-- Core actions
-- =========================
local function normalizeSpeed()
  local xr, yr = getRecords()
  if not xr or not yr then return end

  local vx = tonumber(xr.Value) or 0
  local vy = tonumber(yr.Value) or 0
  local r = math.sqrt(vx*vx + vy*vy)

  -- Guard: if nearly stationary, skip to avoid division by zero / jitter
  if r < (speedTable[1] or 1) then return end

  if index<=1 then
    local target = speedTable[index] or r
    local ratio = target / r
    xr.Value = vx * ratio
    yr.Value = vy * ratio
  else
      local minsp=speedTable[index-1]
      local maxsp=speedTable[index]
      if r<minsp then
         setEventually(xr,yr,vx,vy,r,minsp,outGearMul)
      else
          if r>maxsp then
             setEventually(xr,yr,vx,vy,r,maxsp,outGearMul)
          else
              setEventually(xr,yr,vx,vy,r,maxsp,inGearMul)
          end
      end
  end
end

local function stopSpeed()
  local xr, yr = getRecords()
  if xr and yr then
    xr.Value = 0
    yr.Value = 0
  end
end

-- =========================
-- Hotkeys
-- =========================
incGear = createHotkey(function()
  if index < getLen(speedTable) then
    index = index + 1
  end
end, VK_W)

decGear = createHotkey(function()
  if index > 1 then
    index = index - 1
  end
end, VK_S)

-- Optional single-tap normalize (kept from your original behavior)
hk1 = createHotkey(function()
  normalizeSpeed()
end, VK_UP)

hk2 = createHotkey(function()
  stopSpeed()
end, VK_DOWN)

-- =========================
-- Timer: 50 ms enforcement loop
-- - Holds gear speed while UP is held
-- - Or always enforce if alwaysEnforce = true
-- =========================
gearTimer = createTimer(nil, false)
gearTimer.Interval = TICK_MS
gearTimer.OnTimer = function(t)
  if alwaysEnforce or isKeyPressed(VK_UP) then
    normalizeSpeed()
  end
end
gearTimer.Enabled = true

[DISABLE]

-- Full cleanup (destroy timer and hotkeys; nil references)
if gearTimer then pcall(function() gearTimer.destroy() end) gearTimer = nil end

if hk1 then pcall(function() hk1.destroy() end) hk1 = nil end
if hk2 then pcall(function() hk2.destroy() end) hk2 = nil end
if incGear then pcall(function() incGear.destroy() end) incGear = nil end
if decGear then pcall(function() decGear.destroy() end) decGear = nil end

-- Optional: also clear config/state so re-enable starts fresh
speedTable = nil
index = nil
speedXString = nil
speedYString = nil
alwaysEnforce = nil

